// ssao_debug.psh  — sortie RGBA (gris) pour debug back buffer

Texture2D<uint4> gViewPosNormal : register(t0); // packHalf2x16 lu en uint4
Texture2D<float3> gNoise : register(t1); // bruit (xy, z=0)
Texture2D<float> gLinearDepth : register(t2); // profondeur linéaire

SamplerState gNoiseSampler : register(s0); // WRAP + POINT
SamplerState gDepthSampler : register(s1); // CLAMP + POINT

cbuffer SSAOParams : register(b0)
{
    float4x4 uProjMatrix;
    int uAoIntensity;
    int uKernelSize;
    float uNoiseSize;
    float _pad0;
};

cbuffer SSAOKernel : register(b1)
{
    float3 uAoKernel[512];
};

struct PSIn
{
    float4 SVPos : SV_Position;
};

static float2 UnpackHalf2x16(uint v)
{
    uint2 u = uint2(v & 0xFFFFu, v >> 16);
    return float2(f16tof32(u.x), f16tof32(u.y));
}

static float SmoothStep(float a, float b, float x)
{
    float t = saturate((x - a) / (b - a));
    return t * t * (3.0f - 2.0f * t);
}

float4 main(PSIn IN) : SV_Target
{
    const float BIAS = 0.025f;

    int2 texPos = int2(IN.SVPos.xy);

    // --- Unpack G-Buffer ---
    uint4 vpnu = gViewPosNormal.Load(int3(texPos, 0));
    float2 vp_xy = UnpackHalf2x16(vpnu.x);
    float2 tmp = UnpackHalf2x16(vpnu.y);
    float2 n_yz = UnpackHalf2x16(vpnu.z);

    float3 viewPosition = float3(vp_xy, tmp.x);
    float3 normal = float3(tmp.y, n_yz);

    // Rayon dépendant de la profondeur
    float centerDepth = -viewPosition.z; // > 0 (distance caméra->fragment)
    float radius = centerDepth;

    // Bruit tileable
    float2 noiseUV = IN.SVPos.xy / uNoiseSize;
    float3 randomVec = normalize(gNoise.Sample(gNoiseSampler, noiseUV));

    // TBN via Gram-Schmidt
    float3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
    float3 bitangent = cross(normal, tangent);
    float3x3 TBN = float3x3(tangent, bitangent, normal);

    // SSAO
    float ao = 0.0f;
    [loop]
    for (int i = 0; i < uKernelSize; ++i)
    {
        float3 samplePos = mul(TBN, uAoKernel[i]) * radius + viewPosition;

        float4 clip = mul(uProjMatrix, float4(samplePos, 1.0f));
        float2 uv = clip.xy / clip.w;
        uv = uv * 0.5f + 0.5f;

        float sampleDepth = gLinearDepth.Sample(gDepthSampler, uv);
        float samplePosDepth = -samplePos.z;

        float rangeCheck = (sampleDepth == 0.0f) ? 0.0f
                      : SmoothStep(0.0f, 1.0f, radius / abs(centerDepth - sampleDepth));

        ao += (sampleDepth >= samplePosDepth + BIAS ? 1.0f : 0.0f) * rangeCheck;
    }

    ao = 1.0f - (ao / float(max(1, uKernelSize)));
    ao = pow(ao, float(uAoIntensity));

    //return float4(ao, ao, ao, 1.0f);
    
    // DEBUG : sortir en gris pour back buffer RGBA
    
    float2 uvScreen = IN.SVPos.xy / float2(1280, 720); // ou via cbuffer inv size
    float d = gLinearDepth.Sample(gDepthSampler, uvScreen);
    return float4(d, d, d, 1);
    
    //
}
